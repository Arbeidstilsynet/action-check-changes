name: "Check changes"
author: "Arbeidstilsynet"
description: "Check if specified paths changed since last successful run of a workflow"

inputs:
  token:
    description: "GitHub token for API access (Actions:Read)"
    required: true
  include-paths:
    description: Newline separated list of Git pathspecs to include
    required: true
  exclude-paths:
    description: Newline separated list of Git pathspecs to exclude
    required: false
    default: ""
  workflow-file:
    description: Workflow file (e.g. deploy.yml) whose last successful run determines the base commit
    required: false

outputs:
  changed:
    description: "true if any included (and not excluded) paths changed"
    value: ${{ steps.diff.outputs.changed }}
  base_sha:
    description: Base commit used for diff
    value: ${{ steps.base.outputs.base_sha }}
  head_sha:
    description: Current HEAD sha
    value: ${{ steps.base.outputs.head_sha }}
  changed_files:
    description: Newline separated list of changed files after exclusions
    value: ${{ steps.diff.outputs.changed_files }}

runs:
  using: composite
  steps:
    - name: Determine base (last successful run)
      id: base
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        set -euo pipefail

        # Prefer explicit input; otherwise derive from GITHUB_WORKFLOW_REF:
        # Example GITHUB_WORKFLOW_REF: owner/repo/.github/workflows/test.yml@refs/heads/branch
        if [ -n "${{ inputs.workflow-file }}" ]; then
          WF_FILE='${{ inputs.workflow-file }}'
          echo "Using provided workflow-file input: $WF_FILE"
        else
          WF_FILE=$(echo "${GITHUB_WORKFLOW_REF:-}" | sed -n 's#.*/\.github/workflows/\([^@]*\)@.*#\1#p')
          if [ -n "$WF_FILE" ]; then
            echo "Auto-detected workflow file: $WF_FILE"
          else
            echo "Could not auto-detect workflow file (GITHUB_WORKFLOW_REF='${GITHUB_WORKFLOW_REF:-}'). Will skip API lookup."
          fi
        fi

        BRANCH="${{ github.ref_name }}"
        BASE_SHA=""
        HEAD_SHA=$(git rev-parse HEAD)

        if [ -n "$WF_FILE" ]; then
          echo "Locating last successful run for $WF_FILE on branch $BRANCH"
          JSON=$(gh api "repos/${{ github.repository }}/actions/workflows/${WF_FILE}/runs" \
                  -f branch="$BRANCH" -f status=completed 2>/dev/null || echo '{}')

          LAST_SUCCESS=$(echo "$JSON" | jq -r '
            (.workflow_runs? // [])
            | map(select(.conclusion=="success")) | .[0].head_sha // empty')

          if [ -n "$LAST_SUCCESS" ]; then
            BASE_SHA="$LAST_SUCCESS"
          fi
        else
          echo "Skipping workflow run lookup (no workflow file)."
        fi

        if [ -z "$BASE_SHA" ]; then
          echo "No previous successful run found; falling back to root commit."
          BASE_SHA=$(git rev-list --max-parents=0 HEAD)
        fi

        echo "Base SHA: $BASE_SHA"
        echo "Head SHA: $HEAD_SHA"

        {
          echo "base_sha=$BASE_SHA"
          echo "head_sha=$HEAD_SHA"
        } >> "$GITHUB_OUTPUT"

    - name: Compute diff
      id: diff
      shell: bash
      run: |
        set -euo pipefail
        BASE_SHA='${{ steps.base.outputs.base_sha }}'
        HEAD_SHA='${{ steps.base.outputs.head_sha }}'
        INCLUDE_RAW='${{ inputs.include-paths }}'
        EXCLUDE_RAW='${{ inputs.exclude-paths }}'

        if [ -z "$INCLUDE_RAW" ]; then
          echo "No include paths provided" >&2
          exit 1
        fi

        # New: only split on newlines so patterns may contain spaces.
        norm_list () {
          # Read stdin, trim leading/trailing whitespace, drop empty lines, dedupe.
          sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e '/^$/d' | sort -u
        }

        mapfile -t INCLUDES < <(printf "%s\n" "$INCLUDE_RAW" | norm_list)
        mapfile -t EXCLUDES < <(printf "%s\n" "$EXCLUDE_RAW" | norm_list)

        echo "Include patterns:"
        printf '  %s\n' "${INCLUDES[@]}"
        if [ ${#EXCLUDES[@]} -gt 0 ]; then
          echo "Exclude patterns:"
          printf '  %s\n' "${EXCLUDES[@]}"
        else
          echo "No exclude patterns."
        fi

        EXCLUDE_SPEC=()
        for p in "${EXCLUDES[@]}"; do
          EXCLUDE_SPEC+=(":(exclude)$p")
        done

        git diff --name-only "$BASE_SHA" "$HEAD_SHA" -- "${INCLUDES[@]}" "${EXCLUDE_SPEC[@]}" > /tmp/changed_files || true

        if [ -s /tmp/changed_files ]; then
          CHANGED=true
        else
          if git diff --quiet "$BASE_SHA" "$HEAD_SHA" -- "${INCLUDES[@]}" "${EXCLUDE_SPEC[@]}"; then
            CHANGED=false
          else
            CHANGED=true
          fi
        fi

        echo "Changed: $CHANGED"
        cat /tmp/changed_files || true

        {
          echo "changed=$CHANGED"
          printf "changed_files="
          awk '{printf "%s%s", NR==1?"":"%0A", $0}' /tmp/changed_files
          echo
        } >> "$GITHUB_OUTPUT"
