name: "Check changes"
author: "Arbeidstilsynet"
description: "Check if specified paths changed since last successful run of a workflow"

inputs:
  token:
    description: "GitHub token for API access (Actions:Read)"
    required: true
  include-paths:
    description: Newline separated list of Git pathspecs to include
    required: true
  exclude-paths:
    description: Newline separated list of Git pathspecs to exclude
    required: false
    default: ""
  workflow-file:
    description: Workflow file (e.g. deploy.yml) whose last successful run determines the base commit
    required: false

outputs:
  changed:
    description: "true if any included (and not excluded) paths changed"
    value: ${{ steps.diff.outputs.changed }}
  base_sha:
    description: Base commit used for diff
    value: ${{ steps.base.outputs.base_sha }}
  head_sha:
    description: Current HEAD sha
    value: ${{ steps.base.outputs.head_sha }}
  changed_files:
    description: Newline separated list of changed files after exclusions
    value: ${{ steps.diff.outputs.changed_files }}

runs:
  using: composite
  steps:
    - name: Determine base (last successful run)
      id: base
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
      run: |
        set -euo pipefail

        # Resolve workflow file (input or auto-detect)
        if [ -n "${{ inputs.workflow-file }}" ]; then
          WF_FILE='${{ inputs.workflow-file }}'
        else
          WF_FILE=$(echo "${GITHUB_WORKFLOW_REF:-}" | sed -n 's#.*/\.github/workflows/\([^@]*\)@.*#\1#p')
        fi

        if [ -n "$WF_FILE" ]; then
          echo "Workflow file: $WF_FILE"
        else
          echo "No workflow file name available (cannot query runs)."
        fi

        BRANCH='${{ github.ref_name }}'
        HEAD_SHA=$(git rev-parse HEAD)
        BASE_SHA=""
        LAST_SUCCESS=""

        if [ -n "$WF_FILE" ] && command -v gh >/dev/null 2>&1; then
          echo "Fetching workflow runs (branch=$BRANCH)..."
          # Keep branch filter so we only look at this branch
          WORKFLOW_RUNS=$(gh api "repos/${{ github.repository }}/actions/workflows/${WF_FILE}/runs" \
                            -f branch="$BRANCH" 2>/dev/null || echo "")
          if [ -z "$WORKFLOW_RUNS" ]; then
            echo "No workflow runs found (first run, permission issue, or filename mismatch)."
          else
            echo "Found workflow runs, filtering successful ones..."
            LAST_SUCCESS=$(echo "$WORKFLOW_RUNS" | jq -r '.workflow_runs[] | select(.conclusion=="success") | .head_sha' | head -n 1 || echo "")
            echo "Last successful commit SHA: ${LAST_SUCCESS:-none}"
          fi
        else
          echo "Skipping API lookup (missing workflow file or gh CLI)."
        fi

        if [ -z "$LAST_SUCCESS" ]; then
          echo "No previous successful run; using first commit as base."
          BASE_SHA=$(git rev-list --max-parents=0 HEAD)
        else
          BASE_SHA="$LAST_SUCCESS"
        fi

        echo "Base SHA: $BASE_SHA"
        echo "Head SHA: $HEAD_SHA"

        {
          echo "base_sha=$BASE_SHA"
          echo "head_sha=$HEAD_SHA"
        } >> "$GITHUB_OUTPUT"

    - name: Compute diff
      id: diff
      shell: bash
      run: |
        set -euo pipefail
        BASE_SHA='${{ steps.base.outputs.base_sha }}'
        HEAD_SHA='${{ steps.base.outputs.head_sha }}'
        INCLUDE_RAW='${{ inputs.include-paths }}'
        EXCLUDE_RAW='${{ inputs.exclude-paths }}'

        if [ -z "$INCLUDE_RAW" ]; then
          echo "No include paths provided" >&2
          exit 1
        fi

        # New: only split on newlines so patterns may contain spaces.
        norm_list () {
          # Read stdin, trim leading/trailing whitespace, drop empty lines, dedupe.
          sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e '/^$/d' | sort -u
        }

        mapfile -t INCLUDES < <(printf "%s\n" "$INCLUDE_RAW" | norm_list)
        mapfile -t EXCLUDES < <(printf "%s\n" "$EXCLUDE_RAW" | norm_list)

        echo "Include patterns:"
        printf '  %s\n' "${INCLUDES[@]}"
        if [ ${#EXCLUDES[@]} -gt 0 ]; then
          echo "Exclude patterns:"
          printf '  %s\n' "${EXCLUDES[@]}"
        else
          echo "No exclude patterns."
        fi

        EXCLUDE_SPEC=()
        for p in "${EXCLUDES[@]}"; do
          EXCLUDE_SPEC+=(":(exclude)$p")
        done

        git diff --name-only "$BASE_SHA" "$HEAD_SHA" -- "${INCLUDES[@]}" "${EXCLUDE_SPEC[@]}" > /tmp/changed_files || true

        if [ -s /tmp/changed_files ]; then
          CHANGED=true
        else
          if git diff --quiet "$BASE_SHA" "$HEAD_SHA" -- "${INCLUDES[@]}" "${EXCLUDE_SPEC[@]}"; then
            CHANGED=false
          else
            CHANGED=true
          fi
        fi

        echo "Changed: $CHANGED"
        cat /tmp/changed_files || true

        {
          echo "changed=$CHANGED"
          printf "changed_files="
          awk '{printf "%s%s", NR==1?"":"%0A", $0}' /tmp/changed_files
          echo
        } >> "$GITHUB_OUTPUT"
